spring.application.name=backend
server.port=8080

# --- VERITABANI BAGLANTISI ---
# NOTE: If running locally without Docker, change 'library_mysql_db' to 'localhost'
# DOCKER DUZELTMESI: Eger backend Docker icinde calisiyorsa 'localhost' veritabani konteynerini gormez.
# Docker Compose servis adini (muhtemelen 'library_mysql_db' veya 'mysql_db') yazmalisin.
# Simdilik localhost bir sekilde calistiysa kalsin ama dogrusu servis adidir.
spring.datasource.url=jdbc:mysql://mysqldb:3306/library_db_v2?createDatabaseIfNotExist=true&useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC&characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=root

# --- JPA & HIBERNATE ---
# SORUNUN COZUMU BURADA: 'update' modunda data.sql calisinca "Zaten var" (Duplicate Entry) hatasi aliyorsun.
# Geliştirme/Test surecinde her baslangicta veritabani silinip yeniden kurulmalidir.
spring.jpa.hibernate.ddl-auto=create-drop

spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true

# MySQL 8 Dialect
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# --- INITIALIZATION ---
spring.sql.init.mode=always
# Bu ayar dogru: Tablolar olusmadan veri eklemeyi engeller.
spring.jpa.defer-datasource-initialization=true
spring.sql.init.encoding=UTF-8

# --- DIGER ---
spring.main.allow-circular-references=true
logging.level.org.springframework.security=INFO

# 256-bit (32 byte) veya daha uzun bir anahtar şarttır!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
application.security.jwt.expiration=86400000